---
title: 몽고 DB
tags: database, mongo
---

# mongoDB

NoSQL의 DBMS의 한 종류로 Document로 저장되는 데이터 구조를 사용한다. 이는 JSON형태의 스키마형 문서를 사용한다.

## 문서(Document)

여러개의 키와 값을 가지고 있는 데이터 컬렉션이다. 키는 중복이 될 수 없고, 값은 여러개를 가질 수 있는데 어떤 데이터 형식을 쓸 수 있는지는 후술한다. 문서 내의 최대 크기는 16MB이다.

## MySQL보다 MongoDB를 선택하게 되는 이유

- 객체지향 프로그래밍 언어에 자연스럽게 매핑이 된다.

- 복잡한 개체 관계형 매핑(ORM) 레이어가 제거된다.

  > 테이블과 객체간의 매핑을 하는 것

- 유연성으로 비즈니스 요구 사항에 따라서 쉽게 변경이 가능하다

## MySQL과의 비교

### MySQL

- 관계형 데이터 베이스이다.
- 참조 무결성을 적용한다.
- 쿼리 언어(SQL)를 사용한다.
- 필요한 데이터의 뷰를 만들기위해 Join을 하는 쿼리를 작성해야한다.
- 스키마를 미리 구성해두고 DB에 저장하기 위해선 데이터는 이 스키마와 일치해야 한다.
- 안정성을 제공하는대신 유연성을 버렸다.
- 확장을 하려면 데이터 마이그레이션이 필요할 수 있다.
- 인덱싱을 이용한 고성능 조인에 최적화 되어있다.

### 몽고DB

- NoSQL이다.
- 무결성이 보장되지 않는다.
- 키/값 쌍으로 구성된다.
- 컬렉션의 키/값 쌍의 구조는 문서(document)마다 다를 수 있다.
- 좀더 유연하게 접근 가능하다.
- 확장이 쉽다.
- 쓰기 성능에 최적화 되어있다.
- 조인은 사용하지 않기 때문에 RDBMS의 조인 조회보다 비용이 적을 수 있다.

### 데이터 구조

JSON 형식의 Document를 따른다.

```json
{
    id: "id001",
    title: "하이",
    body: "마이 네임 이즈 케멀",
    writeDate: 2020-01-01T00:00:00
	modifyDate: 2020-01-01T00:00:00
    writer: {
    	id: "camel0101",
    	name: "케멀"
	}
    openStatus: "OPEN"
    tags: ["소개", "글씨", "예제"]
}
```

표현할 수 있는 데이터 형식은 다음과 같이 있다

| 형식                     | 숫자 |
| ------------------------ | ---- |
| 실수형(Double)           | 1    |
| 문자열(String)           | 2    |
| 객체                     | 3    |
| 배열                     | 4    |
| 바이너리 데이터          | 5    |
| 객체 ID                  | 7    |
| 불린(Boolean)            | 8    |
| 날짜(Date)               | 9    |
| 널(Null)                 | 10   |
| 정규표현식               | 11   |
| 자바스크립트             | 13   |
| 심볼(Symbol)             | 14   |
| 자바스크립트(with scope) | 15   |
| 32비트 정수형            | 16   |
| 타임스탬프               | 17   |
| 64비트 정수형            | 18   |
| Min 키                   | 255  |
| Max 키                   | 127  |

## 특징

MySQL과 비교사항과 중복되는 내용은 없음

- 비동기 드라이버 사용 가능 (JDBC는 동기 드라이버)
- RDB와 개념이 유사하기 때문에 어색하지는 않음
- 복잡한 쿼리를 사용할 수 없다.(join 등)
- 메모리 사용량이 큰 편이다.
- ACID가 보장되지 않음
- 기존 RDB보다 100 배이상의 퍼포먼스를 냄



## 그래서 언제 사용?

1. null 필드가 많이 존재할 때
2. 로그성 데이터나 빅데이터 처리의 중간 저장소
3. 압도적인 퍼포먼스가 필요할 때
4. index 활용
5. 집계 연산, paging 등이 필요할 때

## 사용하지 말아야할 때

- 데이터 무결성 중요할 때
- 데이터 타입 검사나 연관 관계가 중요할 때