# Spring Web Flux

5.0에 추가된 스프링 웹플럭스는 리액티브 스택 웹 프레임워크이다. 완전하게 논블로킹으로 동작한다. Netty, U ndertow, 서블릿 3.1+ 컨테이너 서버에서 실행된다.

spring-webmvc, spring-webflux 스프링 프레임워크에 공존한다. 둘 중 하나를 고를 수도 있고 둘 다 사용할 수 있다. 예를들어 스프링 MVC 컨트롤러에서 리액티브 WebClient를 사용하는 방식으로 사용할 수 있다.

## 1. 개요

webflux 탄생 이유는 적은 쓰레드로 동시 처리를 제어

적은 하드웨어 리소스를 확장

서블릿으로 논 블로킹을 구현하려면 다른 동기 처리나, 블로킹 방식을 쓰는 API를 사용하기 어렵다.

이러한 점 때문에 논블로킹과도 잘 동작하는 새 공통 API를 만들게되었다.

리액티브 스트림은 back pressure를 통한 비동기 컴포넌트 간의 상호작용을 정의한 간단한 스펙이다.  리액티브 스트림을 쓰는 주 목적은 subscriber가 publisher의 데이터 생산 속도를 제어하는 것이다.

리액티브 스트림은 라이브러리와 기반 구조에 사용되는 컴포넌트에는 유용해도, 애플리케이션 API에서 다루기엔 너무 저수준이다. 애플리케이션은 비동기 로직을 만들기 위한 풍부한 고수준 함수형 API가 필요하다.

Reactor는 스플링 웹플럭스가 선택한 리액티브 라이브러리다. 리액터는 Mono와 Flux API 타입을 제공한다. 데이터 시퀀스를 0~1개는 Mono, 0~N개는 Flux로 표현할 수 있다.

### 1.1.3 Programming Models

스프링 웹플럭스 두가지 프로그래밍 모델을 지원

1. Annotated Controllers: 스프링 MVC와 동일하고 spring-web 모듈에 있는 같은 어노테이션을 사용한다. 스프링 MVC와 웹 플럭스 컨트롤러 모두 리액티브 리턴 타입을 지원하기 때문에 이 둘을 구분하기 어렵다. 웹플럭스에선 @RequestBody로 리액티브 인자를 받을 수 있다
2. Functional Endpoints: 경량화된 람다 기반 함수형 프로그래밍 모델. 요청을 라우팅해주는 조그마한 라이브러리나 유틸리티 모음이다.

### 스프링 or 웹플럭스

- 이미 잘 동작하는 스프링 MVC가 있다면 굳이 바꿀 필요는 없다.
- 논블로킹 웹 스택을 알아보고 있다면, 스프링 웹플럭스는 다른 웹 스택과 같은 환경을 제공하면서도, 다양한 서버와 여러 리액티브 라이브러리를 지원하며, 두 가지 프로그래밍 모델을 사용할 수 있다.
- 자바8 람다나 코틀린으로 개발할 수 있는 경량의 함수형 웹 프레임워크를 찾고 있다면, 스프링 웹 플럭스의 함수형 웹 엔드포인트를 사용하면 된다.
- 마이크로 아키텍처에선 스프링 MVC로 만든 어플리케이션과, 스프링 웹플럭스 컨트롤러나 함수형 엔드포인트를 사용한 어플리케이션을 조합할 수 있다.
- 블로킹 방식의 영속성 API(JPA, JDBC)나 네트워크 API를 사용하고 있다면 스프링 MVC가 최소한 아키텍처를 통일할 수 있으므로 가장 좋은 선택이다.
- 스프링 MVC 어플리케이션에서 외부 서비스를 호출한다면 webClient를 사용할 수 있다. 스프링 MVC 컨트롤러 메소드에서도 리액티브 타입을 반환할 수 있다. 서비스 호춝에 지연이 있거나 여러 서비스가 엮여 있는 API라는 효과가 더 좋을 것이다.
- 팀 규모가 크다면 논블로킹, 함수형, 선언적 프로그래밍은 러닝커브가 높다는 점도 고려해야한다. 한 번에 전환하지 않고 리액티브 WebClient부터 적용해보는 것도 괜찮다.

### 서버

웹플럭스 스타터는 Netty를 기본으로 사용한다. dependency를 수정하면 톰캣으로 바꿀 수 있다. 톰캣과 동작방식의 차이는 스프링 MVC는 서블릿의 블로킹 I/O를 사용하고, 애플리케이션에서 필요하면 서블릿 API를 직접 사용할 수 있다. 스프링 웹플럭스는 서블릿 3.1 논블로킹 I/O로 동작하며, 서블릿 API는 저수준 어댑터에서 사용하기 때문에 노출돼 있지 않다.

### 동시성 모델

스프링 MVC는 애플리케이션이 처리 중인 쓰레드가 잠시 중단될 수 있다.(외부 서비스를 호출했을 때) 그렇기 때문에 서블릿 컨테이너는 이 블로킹을 대비해 큰 쓰레드 풀로 요청을 처리한다.

스프링 웹플럭스는 실행 중인 쓰레드가 중단되지 않는다는 전제가 있다. 따라서 논블로킹 서버는 작은 쓰레드 풀을 고정해놓고 요청을 처리한다.

